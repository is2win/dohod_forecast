# Алгоритм прогнозирования дивидендных выплат

## Общее описание

Данный алгоритм используется для прогнозирования дивидендных выплат на основе исторических данных. Он анализирует прошлые выплаты дивидендов компаний и создает прогнозы на будущие периоды (до 10 лет вперед). Алгоритм учитывает сезонность выплат, исторические размеры дивидендов и структуру выплат по кварталам.

## Входные данные

- **Исторические данные о дивидендах**: информация о прошлых выплатах (дата, сумма, период)
- **Список акций**: список компаний для анализа
- **Параметры прогнозирования**: количество лет для прогнозирования

## Основные шаги алгоритма

### 1. Сбор исторических данных

- Парсинг сайта с информацией о дивидендах (dohod.ru)
- Анализ таблиц с историческими выплатами
- Выделение информации из таблицы "Все выплаты" (игнорирование таблицы "Совокупные выплаты по годам")
- Структурирование данных о фактических выплатах дивидендов

### 2. Предварительная обработка данных

- Очистка данных от дубликатов и некорректных значений
- Извлечение и преобразование дат
- Определение квартала для каждой выплаты
- Извлечение размера дивиденда
- Разделение данных на фактические значения и прогнозы с сайта
- Добавление поля `forecast_strategy` для всех записей:

```python
# Добавляем поле стратегии прогноза для всех записей
df['forecast_strategy'] = df['forecast_type'].apply(
    lambda x: "0 - Фактические данные" if x == 0 else "1 - Прогноз сайта"
)
```

### 3. Основной алгоритм прогнозирования

Алгоритм использует каскадный подход, применяя следующие стратегии в порядке приоритета:

#### 3.1. Прогнозирование на основе квартальных данных

Если для компании есть достаточно квартальных исторических данных:

1. **Группировка данных по кварталам**:
   - Для каждого квартала (Q1, Q2, Q3, Q4) собираются исторические данные
   - Расчет типичных дат выплат для каждого квартала

2. **Статистический анализ**:
   - Рассчитывается средний размер дивиденда для каждого квартала
   - Определяется наиболее типичный месяц выплаты
   - Определяется типичный день месяца для выплаты

3. **Создание прогнозов**:
   - Для каждого будущего года и каждого квартала создается прогноз
   - Используются рассчитанные средние значения дивидендов
   - Даты выплат определяются на основе исторического анализа

```python
# Если у нас есть квартальные данные, используем их для прогноза
for quarter, history in ticker_quarters.items():
    if not history:
        continue
    
    # Рассчитываем средний дивиденд за квартал
    avg_dividend = sum(item['dividend_value'] for item in history) / len(history)
    
    # Определяем типичный месяц выплаты
    months = [item['month'] for item in history if pd.notnull(item['month'])]
    
    if not months:
        # Если нет данных о месяце, используем текущий месяц
        most_common_month = datetime.now().month
    else:
        most_common_month = int(max(set(months), key=months.count))
    
    # Определяем типичный день выплаты
    days = [item['record_date'].day for item in history 
           if isinstance(item['record_date'], datetime) 
           and item['record_date'].month == most_common_month]
    
    if not days:
        most_common_day = 15  # По умолчанию середина месяца
    else:
        most_common_day = int(sum(days) // len(days))
    
    logger.info(f"Для {ticker}, Q{quarter}: месяц={most_common_month}, день={most_common_day}, средний дивиденд={avg_dividend:.2f}")
    
    # Создаем прогнозы на будущие периоды
    for future_year in range(current_year + 1, current_year + years + 1):
        # ...создание прогноза...
        forecast_data.append({
            'ticker': ticker,
            'name': group['name'].iloc[0],
            'record_date': forecast_date,
            'record_date_str': forecast_date.strftime('%d.%m.%Y'),
            'dividend_value': dividend_value,
            'period': f"Q{quarter} {future_year}",
            'forecast_type': 2,  # Наш прогноз (тип 2)
            'year': future_year,
            'quarter': quarter,
            'month': forecast_date.month,
            'announcement_date': "no data",
            'forecast_strategy': "3.1 - Квартальные данные"  # Стратегия 3.1 из документации
        })
```

#### 3.2. Прогнозирование на основе дат выплат внутри года

Если квартальных данных недостаточно, но есть информация о датах выплат внутри года:

1. **Анализ дат выплат**:
   - Собираются все уникальные даты выплат (месяц-день)
   - Для каждой даты рассчитывается средний дивиденд

2. **Определение квартала по дате**:
   - Для каждой даты определяется соответствующий квартал
   - Если невозможно определить по историческим данным, используется расчет по месяцу

3. **Создание прогнозов**:
   - Для каждой исторической даты выплаты и каждого будущего года создается прогноз
   - Дивиденд прогнозируется на основе среднего значения для этой даты

```python
# Если у нас нет квартальных данных, но есть исторические даты выплат внутри года
if ticker_forecast_count == 0 and annual_payment_dates:
    logger.info(f"Для {ticker} используем исторические даты выплат внутри года для прогноза")
    
    # Для каждой уникальной даты внутри года делаем прогноз
    for (month, day), payments in annual_payment_dates.items():
        # Считаем средний дивиденд для этой даты
        avg_dividend = sum(item['dividend_value'] for item in payments) / len(payments)
        
        # Определяем квартал (если возможно)
        quarters = [item['quarter'] for item in payments if item['quarter'] is not None]
        if quarters:
            # Берем наиболее частый квартал
            quarter = max(set(quarters), key=quarters.count)
        else:
            # Определяем квартал по месяцу
            quarter = (month - 1) // 3 + 1
        
        logger.info(f"Для {ticker}, дата {month}-{day}: квартал={quarter}, средний дивиденд={avg_dividend:.2f}")
        
        # Создаем прогнозы на будущие периоды
        for future_year in range(current_year + 1, current_year + years + 1):
            # ...создание прогноза...
            forecast_data.append({
                'ticker': ticker,
                'name': group['name'].iloc[0],
                'record_date': forecast_date,
                'record_date_str': forecast_date.strftime('%d.%m.%Y'),
                'dividend_value': dividend_value,
                'period': f"Q{quarter} {future_year}",
                'forecast_type': 2,  # Наш прогноз (тип 2)
                'year': future_year,
                'quarter': quarter,
                'month': forecast_date.month,
                'announcement_date': "no data",
                'forecast_strategy': "3.2 - Даты выплат"  # Стратегия 3.2 из документации
            })
```

#### 3.3. Прогнозирование на основе годовых данных

Если недостаточно информации о квартальных выплатах и датах внутри года:

1. **Расчет среднего годового дивиденда**:
   - Вычисляется средний дивиденд на основе всех исторических выплат

2. **Распределение по кварталам**:
   - Годовой дивиденд равномерно распределяется по кварталам (делится на 4)
   - Используются стандартные даты для каждого квартала (15 марта, 15 июня, 15 сентября, 15 декабря)

3. **Создание прогнозов**:
   - Для каждого квартала и будущего года создается прогноз
   - Дивиденд для каждого квартала составляет 1/4 от среднего годового

```python
# Если все еще нет прогнозов, используем годовые данные
if ticker_forecast_count == 0 and len(all_payments) > 0:
    try:
        logger.info(f"Для {ticker} недостаточно данных о датах выплат, создаем годовой прогноз")
        
        # Рассчитываем средний дивиденд
        avg_dividend = sum(item['dividend_value'] for item in all_payments) / len(all_payments)
        
        # Определяем типичные даты выплат по кварталам
        quarterly_dates = [
            (3, 15),   # Q1 - 15 марта
            (6, 15),   # Q2 - 15 июня
            (9, 15),   # Q3 - 15 сентября
            (12, 15)   # Q4 - 15 декабря
        ]
        
        # Создаем прогнозы для каждого квартала
        for quarter, (month, day) in enumerate(quarterly_dates, 1):
            # Дивиденд за квартал - делим годовой на 4 квартала
            quarterly_dividend = round(avg_dividend / 4, 2)
            
            # ...создание прогноза...
            forecast_data.append({
                'ticker': ticker,
                'name': group['name'].iloc[0],
                'record_date': forecast_date,
                'record_date_str': forecast_date.strftime('%d.%m.%Y'),
                'dividend_value': quarterly_dividend,
                'period': f"Q{quarter} {future_year}",
                'forecast_type': 2,  # Наш прогноз (тип 2)
                'year': future_year,
                'quarter': quarter,
                'month': forecast_date.month,
                'announcement_date': "no data",
                'forecast_strategy': "3.3 - Годовые данные"  # Стратегия 3.3 из документации
            })
    except Exception as e:
        logger.error(f"Ошибка при создании годового прогноза для {ticker}: {e}")
```

В особых случаях, когда невозможно создать квартальные прогнозы, алгоритм создает единый годовой прогноз:

```python
# Если квартальные прогнозы не получились, делаем хотя бы один годовой прогноз
try:
    # ...определяем дату и размер выплаты...
    
    # Добавляем годовой прогноз
    forecast_data.append({
        'ticker': ticker,
        'name': group['name'].iloc[0],
        'record_date': forecast_date,
        'record_date_str': forecast_date.strftime('%d.%m.%Y'),
        'dividend_value': round(yearly_dividend, 2),
        'period': f"Год {future_year}",
        'forecast_type': 2,  # Наш прогноз (тип 2)
        'year': future_year,
        'quarter': None,  # Годовой прогноз без квартала
        'month': forecast_date.month,
        'announcement_date': "no data",
        'forecast_strategy': "3.3 - Единый годовой"  # Вариант стратегии 3.3
    })
except Exception as e:
    logger.error(f"Ошибка при создании единого годового прогноза для {ticker}: {e}")
```

#### 3.4. Аварийная стратегия прогнозирования

Если нет никаких исторических данных для прогнозирования:

1. **Создание шаблонных прогнозов**:
   - Используются стандартные даты для каждого квартала
   - Дивиденд устанавливается равным нулю для всех прогнозов
   - Создаются прогнозы для каждого квартала и каждого будущего года

```python
# Если всё еще нет прогнозов, создаем что-то минимальное
if ticker_forecast_count == 0:
    try:
        logger.info(f"Для {ticker} создаем минимальный прогноз на основе доступной информации")
        
        # Устанавливаем дивиденд равным нулю
        default_dividend = 0.0
        
        # Создаем стандартные квартальные даты
        quarterly_dates = [
            (3, 15),   # Q1 - 15 марта
            (6, 15),   # Q2 - 15 июня
            (9, 15),   # Q3 - 15 сентября
            (12, 15)   # Q4 - 15 декабря
        ]
        
        # Создаем прогнозы для каждого квартала
        for quarter, (month, day) in enumerate(quarterly_dates, 1):
            # Дивиденд за квартал всегда равен нулю
            quarterly_dividend = 0.0
            
            for future_year in range(current_year + 1, current_year + years + 1):
                try:
                    forecast_date = datetime(future_year, month, day)
                    
                    # Добавляем прогноз для квартала
                    forecast_data.append({
                        'ticker': ticker,
                        'name': group['name'].iloc[0],
                        'record_date': forecast_date,
                        'record_date_str': forecast_date.strftime('%d.%m.%Y'),
                        'dividend_value': quarterly_dividend,
                        'period': f"Q{quarter} {future_year}",
                        'forecast_type': 2,  # Наш прогноз (тип 2)
                        'year': future_year,
                        'quarter': quarter,
                        'month': forecast_date.month,
                        'announcement_date': "no data",
                        'forecast_strategy': "3.4 - Аварийная стратегия"  # Стратегия 3.4 из документации
                    })
                    ticker_forecast_count += 1
                except Exception as e:
                    logger.error(f"Не удалось создать дефолтный прогноз для {ticker} Q{quarter} {future_year}: {e}")
                    continue
    except Exception as e:
        logger.error(f"Ошибка при создании минимального прогноза для {ticker}: {e}")
```

### 4. Обработка специальных случаев

#### 4.1. Учет прогнозов с сайта

Если для компании уже есть прогноз с сайта на определенный период:
- Используется дата и размер дивиденда из прогноза сайта
- Приоритет отдается прогнозу с сайта перед расчетным прогнозом

```python
# Проверяем, есть ли прогноз с сайта доход на этот год и квартал
forecast_key = f"{future_year}-{quarter}"
site_forecast = site_forecasts.get(forecast_key)

# Если есть прогноз сайта, используем его дату, иначе генерируем свою
if site_forecast and site_forecast['record_date']:
    forecast_date = site_forecast['record_date']
    # Используем дивиденд из прогноза сайта
    dividend_value = site_forecast['dividend_value']
else:
    # Используем наш расчетный дивиденд
    dividend_value = round(avg_dividend, 2)
```

#### 4.2. Обработка невалидных дат

Для невалидных дат (например, 30 февраля) применяются следующие правила:
- Для февраля в високосном году используется 29 февраля, в невисокосном - 28 февраля
- Для месяцев с 30 днями (апрель, июнь, сентябрь, ноябрь) используется 30 число
- В остальных случаях дата корректируется на последний день предыдущего месяца

```python
try:
    forecast_date = datetime(future_year_int, month_int, day_int)
except ValueError:
    # Обработка ошибок с невалидными датами
    if month_int == 2 and day_int > 28:
        # Для февраля используем последний день месяца
        if future_year_int % 4 == 0 and (future_year_int % 100 != 0 or future_year_int % 400 == 0):
            # Високосный год
            forecast_date = datetime(future_year_int, 2, 29)
        else:
            # Не високосный год
            forecast_date = datetime(future_year_int, 2, 28)
    elif day_int > 30 and month_int in [4, 6, 9, 11]:
        # Для месяцев с 30 днями
        forecast_date = datetime(future_year_int, month_int, 30)
    else:
        # Для других случаев используем предыдущий месяц
        if month_int > 1:
            next_month = datetime(future_year_int, month_int, 1)
            forecast_date = next_month - timedelta(days=1)
        else:
            forecast_date = datetime(future_year_int - 1, 12, 31)
```

## Результаты прогнозирования

### Типы прогнозов и стратегий

В результате каждая запись относится к одному из трех типов прогнозов:
1. **Фактические данные (тип 0)** - реальные выплаты из истории
2. **Прогнозы с сайта (тип 1)** - прогнозы, взятые с источника данных
3. **Наши прогнозы (тип 2)** - прогнозы, сгенерированные алгоритмом

И одной из стратегий прогнозирования:
1. **0 - Фактические данные** - для исторических выплат
2. **1 - Прогноз сайта** - для прогнозов с сайта
3. **3.1 - Квартальные данные** - прогноз на основе квартальных выплат
4. **3.2 - Даты выплат** - прогноз на основе дат выплат
5. **3.3 - Годовые данные** - прогноз на основе годовых данных
6. **3.4 - Аварийная стратегия** - запасной вариант при отсутствии данных

### Формат выходных данных

Результаты прогнозирования содержат следующие поля:
- **ticker**: тикер акции
- **name**: название компании
- **record_date**: дата закрытия реестра
- **record_date_str**: дата в строковом формате
- **dividend_value**: размер дивиденда
- **period**: период выплаты (например, "Q2 2025")
- **forecast_type**: тип прогноза (0, 1 или 2)
- **forecast_type_str**: текстовое описание типа прогноза
- **forecast_strategy**: стратегия прогнозирования (одна из перечисленных выше)
- **year**: год выплаты
- **quarter**: квартал выплаты
- **month**: месяц выплаты
- **announcement_date**: дата объявления дивиденда (если известна)

## Сохранение результатов

Результаты прогнозирования сохраняются в двух форматах:
1. **Excel файл** - для удобства просмотра и анализа
2. **JSON файл** - для дальнейшей обработки и интеграции с другими системами

Пример сохранения результатов:

```python
# Сохранение в Excel
output_df.to_excel(filename, index=False)

# Сохранение в JSON
with open(filename, 'w', encoding='utf-8') as f:
    json.dump(records, f, ensure_ascii=False, indent=4)
```

## Особенности и ограничения

- Алгоритм основан на предположении, что компании сохраняют схожий паттерн выплат дивидендов со временем
- При недостатке данных качество прогнозов может снижаться
- Внешние факторы (экономические кризисы, смена политики выплат) не учитываются напрямую
- Прогноз основан исключительно на исторических данных без учета фундаментальных показателей компании
- В случае полного отсутствия данных все прогнозные дивиденды устанавливаются в нулевое значение

## Возможные улучшения алгоритма

1. Учет трендов изменения размера дивидендов со временем
2. Интеграция с финансовыми показателями компаний
3. Использование машинного обучения для более точного прогнозирования
4. Учет сезонных факторов и специфики отраслей
5. Добавление анализа вероятности выплаты дивидендов 